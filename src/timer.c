#include "timer.h"

#include <stdio.h>
#include <string.h>

#include "bit.h"
#include "gpio.h"
#include "uart.h"

/* TIMx_CR1 - configuration register 1 */
/* auto-reload preload enable
 * 1 - TIMx_ARR register is buffered
 */
#define ARPE_START_BIT (7)

/* one-pulse mode
 * 1 - counter stops counting on the next update event (clearing the CEN bit)
 */
#define OPM_START_BIT (3)

/* update request source
 * 0 - counter overflow and setting the UG bit generate an UEV if enabled
 * 1 - only counter overflow generates an UEV if enabled
 */
#define URS_START_BIT (2)

/* update disable
 * this bit is set and cleared by software to enable/disable update interrupt
 * (UEV) event generation.
 * 0 - UEV enabled. an UEV is generated by one of the following events:
 *	 - counter overflow
 *   - setting the UG bit
 * 1 - UEV disabled
 */
#define UDIS_START_BIT (1)

/* counter enable
 * 1 - counter enabled
 */
#define CEN_START_BIT (0)

/* TIMx_DIER - interrupt enable register */
/* capture/compare 1 interrupt enable
 * 1 - CC1 interrupt enabled
 */
#define CC1IE_START_BIT (1)

/* update interrupt enable
 * 1 - update interrupt enabled
 */
#define UIE_START_BIT (0)

/* TIMx_SR - status register */
/* capture/compare 1 overcapture flag
 * 1 - ther counter value has been captured in TIMx_CCR1 register while CC1IF
 * flag was already set
 */
#define CC1OF_START_BIT (9)

/* capture/compare 1 interrupt flag
 * If channel CC1 is configured as output:
 * 1 - the content of the counter TIMx_CNT matches the content of the TIMx_CCR1
 * register
 * If channel CC1 is configured as input:
 * 1 - the counter value has been captured in TIMx_CCR1 register (an edge has
 * been detected on IC1 which matches the selected polarity)
 */
#define CC1IF_START_BIT (1)

/* update interrupt flag
 * this bit is set by hardware on an update event. it is cleared by software.
 * 1 - update interrupt pending. this bit is set by hardware when the registers
 * are updated:
 *   - at overflow and if UDIS='0' in the TIMx_CR1 register.
 *   - When CNT is reinitialized by software using the UG bit in TIMx_EGR
 * register, if URS='0' and UDIS='0' in the TIMx_CR1 register
 */
#define UIF_START_BIT (0)

/* TIMx_EGR - event generation register */
/* capture/compare 1 generation
 * this bit is set by software in order to generate an event, it is
 * automatically cleared by hardware.
 * 1 - a capture/compare event is generated on channel1:
 */
#define CC1G_START_BIT (1)

/* update generation
 * this bit can be set by software, it is automatically cleared by hardware.
 * 1 - re-initialized the counter and generates an update of the registers.
 */
#define UG_START_BIT (0)

/* TIMx_CCMR1 */
/* TIMx_CCER */

/* TIMx_CNT - counter */
/* CNT[15:0] - counter value */
#define CNT_START_BIT (0)
#define CNT_BITS (16)

/* TIMx_PSC - prescaler */
/* PSC[15:0] - prescaler value */
#define PSC_START_BIT (0)
#define PSC_BITS (16)

/* TIMx_ARR - auto-reload register */
/* ARR[15:0] - auto-reload value */
#define ARR_START_BIT (0)
#define ARR_BITS (16)

/* TIMx_CCR1 - capture/compare register 1 */
/* CCR1[15:0] - capture/compare 1 value */

/* TIM11_OR - option register 1 */
/* TI1_RMP - TIM11 input 1 remapping capability
 * 00,01,11 - TIM11 channel 1 is connected to the GPIO
 * 10 - HSE_RTC clock (HSE divided by programmable prescaler) is connected to
 * the TIM11_CH1 input for measurement purposes
 */

static Tim1xType *rTim11 = (Tim1xType *)TIM11_BASE;

int initTimer11(uint32_t periodInMs)
{
	// 01. disable counter by resetting CE in TIMx_CR1
	SetBits(&rTim11->cr1, CEN_START_BIT, 1, BIT_DISABLE);
	// 02. re-initialize the counter by setting UG in TIMx_EGR
	SetBits(&rTim11->egr, UG_START_BIT, 1, BIT_ENABLE);
	// 03. enable auto-reload preload by setting ARPE in TIMx_CR1
	SetBits(&rTim11->cr1, ARPE_START_BIT, 1, BIT_ENABLE);
	// 04. determine clock prescaler by setting CK_PSC in TIMx_PSC
	SetBits(&rTim11->psc, PSC_START_BIT, PSC_BITS, 9600);
	// 05. determine auto-reload value by setting ARR in TIMx_ARR
	SetBits(&rTim11->arr, ARR_START_BIT, ARR_BITS, periodInMs * 10);
	// 06. enable update interrupt event by resetting UDIS in TIMx_CR1
	SetBits(&rTim11->cr1, UDIS_START_BIT, 1, BIT_DISABLE);
	// 07. enable update interrupt by setting UIE in TIMx_DIER
	SetBits(&rTim11->dier, UIE_START_BIT, 1, BIT_ENABLE);
	// 08. enable counter by setting CE in TIMx_CR1
	SetBits(&rTim11->cr1, CEN_START_BIT, 1, BIT_ENABLE);

	return 0;
}

void handleTimerUpdate(void)
{
	// 01. disable counter by setting CE in TIMx_CR1
	SetBits(&rTim11->cr1, CEN_START_BIT, 1, BIT_DISABLE);
	// 02. read counter from TIMx_CNT
	uint32_t counter = 0;
	GetBits(&rTim11->cnt, CNT_START_BIT, CNT_BITS, &counter);

	// TODO(bjweare): use PWM timer to achive breathing led effect
	// flip led status to achive blinking led effect
	SetLEDStatus(led_pin, led_on);
	led_on = (led_on == true) ? false : true;

	uint8_t *data = (uint8_t *)"Hello World\n";
	size_t size = strlen("Hello World\n");
	UartTransmitMultipleBytes(data, size);

	// 03. clear update interrupt flag by resetting UIF in TIMx_SR
	SetBits(&rTim11->sr, UIF_START_BIT, 1, BIT_DISABLE);
	// 04. disable counter by setting CE in TIMx_CR1
	SetBits(&rTim11->cr1, CEN_START_BIT, 1, BIT_ENABLE);
}
